; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TTL	F:\Source_Code\Visual_Studio\Projects\NATIVE\DLL\NativeConsoleAppAids\NativeConssoleAppAids\IsBufFerFromHeap.c
	THUMB
	.drectve
	DCB	"-defaultlib:MSVCRTD "
	DCB	"-defaultlib:OLDNAMES "

	.msvcjmc
|__2CC6E67D_corecrt_stdio_config@h| DCB 0x1
|__05476D76_corecrt_wstdio@h| DCB 0x1
|__A452D4A0_stdio@h| DCB 0x1
|__7B7A869E_ctype@h| DCB 0x1
|__457DD326_basetsd@h| DCB 0x1
|__4384A2D9_corecrt_memcpy_s@h| DCB 0x1
|__4E51A221_corecrt_wstring@h| DCB 0x1
|__2140C079_string@h| DCB 0x1
|__29C54D54_arm_neon@h| DCB 0x1
|__1887E595_winnt@h| DCB 0x1
|__9FC7C64B_processthreadsapi@h| DCB 0x1
|__FA470AEC_memoryapi@h| DCB 0x1
|__F37DAFF1_winerror@h| DCB 0x1
|__7A450CCC_winbase@h| DCB 0x1
|__86261D59_stralign@h| DCB 0x1
|__41381B41_corecrt_wconio@h| DCB 0x1
|__C0802A2B_corecrt_wtime@h| DCB 0x1
|__A40A425D_stat@h| DCB 0x1
|__5A74375D_wchar@h| DCB 0x1
|__6B9C2DC0_tchar@h| DCB 0x1
|__E8C324CD_isbufferfromheap@c| DCB 0x1
	EXPORT	|IsBufFerFromHeap|
	EXPORT	|__JustMyCode_Default|
	IMPORT	|__imp_SetLastError|
	IMPORT	|__imp_HeapSize|
	IMPORT	|__imp_GetProcessHeap|
	IMPORT	|__C_specific_handler|
	IMPORT	|__CheckForDebuggerJustMyCode|
;	COMDAT .pdata
.pdata	SEGMENT
|$pdata2$IsBufFerFromHeap| DCD imagerel |IsBufFerFromHeap|
	DCD	imagerel |$unwind3$IsBufFerFromHeap|
;	COMDAT .xdata
.xdata	SEGMENT
|$unwind3$IsBufFerFromHeap| DCD 0x43b0004b
	DCD	0xa8fc09c7
	DCD	0x9ff0280
	DCD	0x3ef8088
	DCD	0xff
	DCD	imagerel |__C_specific_handler|
	DCD	0x1
	DCD	imagerel |$LN15@IsBufFerFr|
	DCD	imagerel |$LN16@IsBufFerFr|
	DCD	imagerel |$LN11@IsBufFerFr|
	DCD	imagerel |$LN12@IsBufFerFr|
;	COMDAT .pdata
.pdata	SEGMENT
|$pdata1$__JustMyCode_Default| DCD imagerel |__JustMyCode_Default|
	DCD	imagerel |$unwind2$__JustMyCode_Default|
;	COMDAT .xdata
.xdata	SEGMENT
|$unwind2$__JustMyCode_Default| DCD 0x10a00005
	DCD	0xff00a8fb
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
.text$mn	SEGMENT

|__JustMyCode_Default| PROC
	push        {r11,lr}
	mov         r11,sp
|$M2|
|$M1|
	pop         {r11,pc}
|$M3|

	ENDP  ; |__JustMyCode_Default|

; Function compile flags: /Odtp
; File f:\source_code\visual_studio\projects\native\dll\nativeconsoleappaids\nativeconssoleappaids\isbufferfromheap.c
;	COMDAT IsBufFerFromHeap
.text$mn	SEGMENT

|IsBufFerFromHeap| PROC

; 76   : {

|$LN21@IsBufFerFr|
	push        {r0,r1}
	push        {r7,r11,lr}
	add         r11,sp,#4
	sub         sp,sp,#0x24
	mov         r7,sp
|$LN34@IsBufFerFr|
	ldr         r0,|$LN30@IsBufFerFr|		; =|__E8C324CD_isbufferfromheap@c|
	bl          __CheckForDebuggerJustMyCode

; 77   : #define HEAP_SIZE_ERROR         MINUS_ONE_WW
; 78   : 
; 79   :     HANDLE   hThisHeap          = NULL ;

	movs        r3,#0
	str         r3,[r7,#4]

; 80   :     DWORD    dwExceptionCode    = ZERO_WW ;

	movs        r3,#0
	str         r3,[r7,#8]

; 81   : 
; 82   : 	Unless ( plpvBuf )

	ldr         r3,[r7,#0x34]
	cmp         r3,#0
	bne         |$LN2@IsBufFerFr|

; 83   : 	{
; 84   : 		return FALSE;

	movs        r3,#0
	str         r3,[r7]
	b           |$LN10@IsBufFerFr|
|$LN2@IsBufFerFr|

; 85   : 	}	// Unless ( plpvBuf )
; 86   : 
; 87   :     //  ------------------------------------------------------------------------
; 88   :     //  Establish which heap to check. This initializes hThisHeap on each call.
; 89   :     //  If no heap is specified (indicated by phHeap being null), the default
; 90   :     //  process heap is assumed.
; 91   :     //  ------------------------------------------------------------------------
; 92   : 
; 93   :     if ( phHeap )

	ldr         r3,[r7,#0x30]
	cmp         r3,#0
	beq         |$LN3@IsBufFerFr|

; 94   :     {   // Test this heap, presumably a private heap.
; 95   :         hThisHeap   = phHeap ;

	ldr         r3,[r7,#0x30]
	str         r3,[r7,#4]

; 96   :     }   // TRUE block, if ( phHeap )

	b           |$LN4@IsBufFerFr|
|$LN3@IsBufFerFr|

; 97   :     else
; 98   :     {   // Use the default process heap.
; 99   :         hThisHeap   = GetProcessHeap ( ) ;

	ldr         r3,|$LN29@IsBufFerFr|		; =|__imp_GetProcessHeap|
	ldr         r3,[r3]
	blx         r3
	str         r0,[r7,#4]

; 100  : 
; 101  :         Unless ( hThisHeap )

	ldr         r3,[r7,#4]
	cmp         r3,#0
	bne         |$LN4@IsBufFerFr|

; 102  :         {   // Verify that Windows gave us the handle.
; 103  :             return FALSE ;

	movs        r3,#0
	str         r3,[r7]
	b           |$LN10@IsBufFerFr|
|$LN4@IsBufFerFr|
|$LN15@IsBufFerFr|

; 104  :         }   // Unless ( hThisHeap )
; 105  :     }   // FALSE block, if ( phHeap )
; 106  : 
; 107  :     __try
; 108  :     {   // __try == try in C++, C#, and VB.NET
; 109  :         if ( HeapSize ( hThisHeap ,
; 110  : 			            HEAP_ALL_FLAGS_OFF_WW ,
; 111  : 			            plpvBuf ) == HEAP_SIZE_ERROR )

	ldr         r2,[r7,#0x34]
	movs        r1,#0
	ldr         r0,[r7,#4]
	ldr         r3,|$LN28@IsBufFerFr|		; =|__imp_HeapSize|
	ldr         r3,[r3]
	blx         r3
	str         r0,[r7,#0xC]
	ldr         r3,[r7,#0xC]
	cmp         r3,#0xFFFFFFFF
	bne         |$LN7@IsBufFerFr|

; 112  :         {   // The structured exception handling will probably render this branch dead.
; 113  :             return FALSE ;

	movs        r3,#0
	str         r3,[r7,#0x10]
	ldr         r3,[r7,#0x10]
	str         r3,[r7]
	b           |$LN10@IsBufFerFr|

; 114  :         }   // TRUE block, if ( HeapSize ( hThisHeap , HEAP_ALL_FLAGS_OFF_WW , plpvBuf ) == HEAP_SIZE_ERROR )

	b           |$LN16@IsBufFerFr|
|$LN7@IsBufFerFr|

; 115  :         else
; 116  :         {   // Memory came from this heap.
; 117  :             return TRUE ;

	movs        r3,#1
	str         r3,[r7,#0x14]
	ldr         r3,[r7,#0x14]
	str         r3,[r7]
	b           |$LN10@IsBufFerFr|
|$LN16@IsBufFerFr|

; 118  :         }   // FALSE block, if ( HeapSize ( hThisHeap , HEAP_ALL_FLAGS_OFF_WW , plpvBuf ) == HEAP_SIZE_ERROR )
; 119  :     }   // Try block ends here.

	b           |$LN10@IsBufFerFr|
|$LN12@IsBufFerFr|
|$LN14@IsBufFerFr|

; 120  :     __except ( dwExceptionCode = GetExceptionCode ( ) )
; 121  :     {   // __except == catch in C++, C#, and VB.NET
; 122  :         SetLastError ( dwExceptionCode ) ;

	ldr         r0,[r7,#8]
	ldr         r3,|$LN27@IsBufFerFr|		; =|__imp_SetLastError|
	ldr         r3,[r3]
	blx         r3

; 123  :         return FALSE ;

	movs        r3,#0
	str         r3,[r7,#0x20]
	ldr         r3,[r7,#0x20]
	str         r3,[r7]
	b           |$LN10@IsBufFerFr|
	b           |$LN10@IsBufFerFr|
|$LN10@IsBufFerFr|

; 124  :     }   // Try/Catch block.
; 125  : }   // IsBufFerFromHeap

	ldr         r0,[r7]
|$M25|
	add         sp,sp,#0x24
	pop         {r7,r11}
	ldr         pc,[sp],#0xC
|$LN32@IsBufFerFr|
|$M33|
	__debugbreak
|$LN26@IsBufFerFr|
|$LN27@IsBufFerFr|
	DCD         |__imp_SetLastError|
|$LN28@IsBufFerFr|
	DCD         |__imp_HeapSize|
|$LN29@IsBufFerFr|
	DCD         |__imp_GetProcessHeap|
|$LN30@IsBufFerFr|
	DCD         |__E8C324CD_isbufferfromheap@c|

	ENDP  ; |IsBufFerFromHeap|

|$LN20@IsBufFerFr|
;	COMDAT .text$x
.text$x	SEGMENT

|IsBufFerFromHeap$filt$0| PROC

; 124  :     }   // Try/Catch block.
; 125  : }   // IsBufFerFromHeap

|$LN11@IsBufFerFr|
|$LN23@IsBufFerFr|

; 120  :     __except ( dwExceptionCode = GetExceptionCode ( ) )

	str         r0,[r7,#0x18]
	ldr         r3,[r7,#0x18]
	ldr         r3,[r3]
	ldr         r3,[r3]
	str         r3,[r7,#0x1C]
	ldr         r3,[r7,#0x1C]
	str         r3,[r7,#8]
	ldr         r0,[r7,#8]
|$M31|
	bx          lr
|$LN24@IsBufFerFr|
|$LN22@IsBufFerFr|

	ENDP  ; |IsBufFerFromHeap$filt$0|

	END
